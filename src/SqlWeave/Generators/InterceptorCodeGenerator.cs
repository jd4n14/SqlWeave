using Microsoft.CodeAnalysis;
using SqlWeave.Generators;
using System.Text;

namespace SqlWeave.Generators;

/// <summary>
/// Generador que crea el código de interceptors optimizados.
/// </summary>
internal static class InterceptorCodeGenerator
{
    /// <summary>
    /// Genera el código completo del interceptor para una llamada SqlWeave.
    /// </summary>
    /// <param name="callInfo">Información de la llamada</param>
    /// <param name="interceptorId">ID único del interceptor</param>
    /// <returns>Código fuente del interceptor</returns>
    public static string GenerateInterceptor(SqlWeaveCallInfo callInfo, int interceptorId)
    {
        if (callInfo.TransformationModel == null)
        {
            return GenerateErrorInterceptor(callInfo, interceptorId, "No transformation model available");
        }

        var sb = new StringBuilder();
        
        // Header del archivo
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine("namespace SqlWeave.Generated;");
        sb.AppendLine();

        // Clase del interceptor
        var className = $"SqlWeaveInterceptor_{interceptorId:D3}";
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Interceptor generado automáticamente para {callInfo.TargetType}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"internal static class {className}");
        sb.AppendLine("{");

        // Método interceptor principal
        GenerateInterceptorMethod(sb, callInfo, interceptorId);

        // Métodos auxiliares
        GenerateHelperMethods(sb, callInfo);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateInterceptorMethod(StringBuilder sb, SqlWeaveCallInfo callInfo, int interceptorId)
    {
        var model = callInfo.TransformationModel!;
        var location = callInfo.Location;
        
        // Atributo de interceptor
        if (location != null)
        {
            var lineSpan = location.GetLineSpan();
            var filePath = lineSpan.Path;
            var line = lineSpan.StartLinePosition.Line + 1;
            var character = lineSpan.StartLinePosition.Character + 1;
            
            sb.AppendLine($"    [InterceptsLocation(@\"{filePath}\", {line}, {character})]");
        }

        // Signature del método
        sb.AppendLine($"    public static List<{callInfo.TargetType}> SqlWeave_{interceptorId:D3}(");
        sb.AppendLine("        this object connection,");
        sb.AppendLine("        string sql,");
        sb.AppendLine("        object? parameters,");
        sb.AppendLine($"        Func<dynamic, SqlWeave.Core.IAggregationMethods, {callInfo.TargetType}> transform)");
        sb.AppendLine("    {");

        // Cuerpo del método
        sb.AppendLine("        // TODO: Implementación real con DataReader");
        sb.AppendLine("        // Por ahora, retornamos datos simulados para testing");
        sb.AppendLine();
        
        GenerateSimulatedData(sb, callInfo);

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateSimulatedData(StringBuilder sb, SqlWeaveCallInfo callInfo)
    {
        var model = callInfo.TransformationModel!;

        sb.AppendLine("        // Datos simulados para demostrar el agrupamiento");
        sb.AppendLine("        var mockData = new[]");
        sb.AppendLine("        {");
        
        // Generar algunos registros de ejemplo
        for (int i = 1; i <= 3; i++)
        {
            sb.AppendLine("            new {");
            
            // Generar propiedades basadas en las claves y mapeos directos
            foreach (var key in model.GroupingKeys)
            {
                var propName = ExtractPropertyName(key.SourceExpression);
                sb.AppendLine($"                {propName} = {i},");
            }

            foreach (var mapping in model.DirectMappings.Take(2)) // Solo las primeras 2
            {
                var propName = ExtractPropertyName(mapping.SourceExpression);
                if (mapping.PropertyType == "string" || mapping.SourceExpression.Contains("\""))
                {
                    sb.AppendLine($"                {propName} = \"Sample{propName}{i}\",");
                }
                else
                {
                    sb.AppendLine($"                {propName} = {i * 10},");
                }
            }

            // Propiedades para agregaciones
            foreach (var agg in model.Aggregations.Take(2))
            {
                var propName = ExtractPropertyName(agg.SourceExpression);
                sb.AppendLine($"                {propName} = {i * 100m},");
            }

            sb.AppendLine("            },");
        }
        
        sb.AppendLine("        };");
        sb.AppendLine();

        // Generar lógica de agrupamiento
        GenerateGroupingLogic(sb, model);
    }

    private static void GenerateGroupingLogic(StringBuilder sb, TransformationModel model)
    {
        // Determinar el tipo de clave
        var keyType = GetKeyType(model.GroupingKeys);
        
        sb.AppendLine($"        // Agrupamiento por {keyType}");
        sb.AppendLine($"        var groups = new Dictionary<{keyType}, List<dynamic>>();");
        sb.AppendLine();
        sb.AppendLine("        foreach (var item in mockData)");
        sb.AppendLine("        {");
        
        // Generar extracción de clave
        GenerateKeyExtraction(sb, model.GroupingKeys, keyType);
        
        sb.AppendLine();
        sb.AppendLine("            if (!groups.ContainsKey(key))");
        sb.AppendLine("                groups[key] = new List<dynamic>();");
        sb.AppendLine();
        sb.AppendLine("            groups[key].Add(item);");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generar construcción de resultados
        GenerateResultConstruction(sb, model);
    }

    private static void GenerateKeyExtraction(StringBuilder sb, List<KeyProperty> keys, string keyType)
    {
        if (keys.Count == 1)
        {
            var key = keys.First();
            var propName = ExtractPropertyName(key.SourceExpression);
            sb.AppendLine($"            var key = ({keyType})item.{propName};");
        }
        else
        {
            // Clave compuesta - usar tupla
            var keyExpressions = new List<string>();
            foreach (var key in keys)
            {
                if (key.Type == KeyType.Composite)
                {
                    keyExpressions.AddRange(key.CompositeKeys.Select(expr => $"item.{ExtractPropertyName(expr)}"));
                }
                else
                {
                    keyExpressions.Add($"item.{ExtractPropertyName(key.SourceExpression)}");
                }
            }
            
            sb.AppendLine($"            var key = ({string.Join(", ", keyExpressions)});");
        }
    }

    private static void GenerateResultConstruction(StringBuilder sb, TransformationModel model)
    {
        sb.AppendLine("        // Construcción de objetos resultado");
        sb.AppendLine("        var results = new List<" + model.TargetTypeName + ">();");
        sb.AppendLine();
        sb.AppendLine("        foreach (var group in groups)");
        sb.AppendLine("        {");
        sb.AppendLine("            var groupItems = group.Value;");
        sb.AppendLine("            var firstItem = groupItems.First();");
        sb.AppendLine();

        // Generar construcción del objeto usando el modelo
        sb.AppendLine("            var result = new " + model.TargetTypeName);
        sb.AppendLine("            {");

        // Propiedades de clave
        foreach (var key in model.GroupingKeys)
        {
            var propName = ExtractPropertyName(key.SourceExpression);
            sb.AppendLine($"                {key.PropertyName} = firstItem.{propName},");
        }

        // Mapeos directos
        foreach (var mapping in model.DirectMappings)
        {
            var propName = ExtractPropertyName(mapping.SourceExpression);
            sb.AppendLine($"                {mapping.PropertyName} = firstItem.{propName},");
        }

        // Agregaciones
        foreach (var agg in model.Aggregations)
        {
            GenerateAggregationCode(sb, agg);
        }

        sb.AppendLine("            };");
        sb.AppendLine();
        sb.AppendLine("            results.Add(result);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return results;");
    }

    private static void GenerateAggregationCode(StringBuilder sb, AggregationMapping agg)
    {
        var propName = ExtractPropertyName(agg.SourceExpression);
        
        switch (agg.Type)
        {
            case AggregationType.Sum:
                sb.AppendLine($"                {agg.PropertyName} = groupItems.Sum(x => (decimal)x.{propName}),");
                break;
            case AggregationType.Count:
                sb.AppendLine($"                {agg.PropertyName} = groupItems.Count,");
                break;
            case AggregationType.Avg:
                sb.AppendLine($"                {agg.PropertyName} = groupItems.Average(x => (decimal)x.{propName}),");
                break;
            case AggregationType.Min:
                sb.AppendLine($"                {agg.PropertyName} = groupItems.Min(x => x.{propName}),");
                break;
            case AggregationType.Max:
                sb.AppendLine($"                {agg.PropertyName} = groupItems.Max(x => x.{propName}),");
                break;
        }
    }

    private static void GenerateHelperMethods(StringBuilder sb, SqlWeaveCallInfo callInfo)
    {
        sb.AppendLine("    // Métodos auxiliares para conversiones y mapeo");
        sb.AppendLine("    // TODO: Implementar helpers para DataReader mapping");
    }

    private static string GenerateErrorInterceptor(SqlWeaveCallInfo callInfo, int interceptorId, string error)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// ERROR: " + error);
        sb.AppendLine($"// Target: {callInfo.TargetType}");
        sb.AppendLine($"// Location: {callInfo.Location?.GetLineSpan().StartLinePosition}");
        return sb.ToString();
    }

    private static string GetKeyType(List<KeyProperty> keys)
    {
        if (keys.Count == 0) return "object";
        if (keys.Count == 1) 
        {
            var key = keys.First();
            if (key.Type == KeyType.Composite)
            {
                // Usar tupla para claves compuestas
                var types = key.CompositeKeys.Select(_ => "object").ToList();
                return $"({string.Join(", ", types)})";
            }
            return "object"; // Tipo genérico por ahora
        }

        // Múltiples claves - usar tupla
        var keyTypes = keys.Select(_ => "object").ToList();
        return $"({string.Join(", ", keyTypes)})";
    }

    private static string ExtractPropertyName(string expression)
    {
        // Extraer nombre de propiedad de expresiones como "item.PropertyName"
        if (expression.StartsWith("item."))
        {
            return expression.Substring(5);
        }

        // Para expresiones más complejas, usar el último segmento
        var parts = expression.Split('.');
        return parts.LastOrDefault() ?? "Property";
    }
}
