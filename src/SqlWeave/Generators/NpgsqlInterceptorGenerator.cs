using Microsoft.CodeAnalysis;
using SqlWeave.Generators;
using System.Text;

namespace SqlWeave.Generators;

/// <summary>
/// Specialized generator for interceptors that work with real NpgsqlConnection.
/// </summary>
internal static class NpgsqlInterceptorGenerator
{
    /// <summary>
    /// Generates a complete interceptor that works with NpgsqlConnection and real DataReader.
    /// </summary>
    public static string GenerateNpgsqlInterceptor(SqlWeaveCallInfo callInfo, int interceptorId)
    {
        if (callInfo.TransformationModel == null)
        {
            return DataReaderInterceptorGenerator.GenerateDataReaderInterceptor(callInfo, interceptorId);
        }

        var sb = new StringBuilder();
        var model = callInfo.TransformationModel!;
        
        // File header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Npgsql;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine("namespace SqlWeave.Generated;");
        sb.AppendLine();

        // Clase del interceptor
        var className = $"NpgsqlInterceptor_{interceptorId:D3}";
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Interceptor con NpgsqlConnection real para {callInfo.TargetType}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"internal static class {className}");
        sb.AppendLine("{");

        // Método interceptor principal
        GenerateNpgsqlMethod(sb, callInfo, interceptorId);

        // Métodos auxiliares
        GenerateNpgsqlHelpers(sb, model);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateNpgsqlMethod(StringBuilder sb, SqlWeaveCallInfo callInfo, int interceptorId)
    {
        var model = callInfo.TransformationModel!;
        var location = callInfo.Location;
        
        // Atributo de interceptor
        if (location != null)
        {
            var lineSpan = location.GetLineSpan();
            var filePath = lineSpan.Path.Replace(@"\", @"\\");
            var line = lineSpan.StartLinePosition.Line + 1;
            var character = lineSpan.StartLinePosition.Character + 1;
            
            sb.AppendLine($"    [InterceptsLocation(@\"{filePath}\", {line}, {character})]");
        }

        // Signature del método
        sb.AppendLine($"    public static async Task<List<{callInfo.TargetType}>> NpgsqlSqlWeave_{interceptorId:D3}(");
        sb.AppendLine("        this NpgsqlConnection connection,");
        sb.AppendLine("        string sql,");
        sb.AppendLine("        object? parameters,");
        sb.AppendLine($"        Func<dynamic, SqlWeave.Core.IAggregationMethods, {callInfo.TargetType}> transform)");
        sb.AppendLine("    {");

        // Cuerpo del método con NpgsqlConnection real
        sb.AppendLine("        // Asegurar que la conexión esté abierta");
        sb.AppendLine("        if (connection.State != ConnectionState.Open)");
        sb.AppendLine("        {");
        sb.AppendLine("            await connection.OpenAsync();");
        sb.AppendLine("        }");
        sb.AppendLine();
        
        sb.AppendLine("        using var command = new NpgsqlCommand(sql, connection);");
        sb.AppendLine();
        
        sb.AppendLine("        // Agregar parámetros si existen");
        sb.AppendLine("        if (parameters != null)");
        sb.AppendLine("        {");
        sb.AppendLine("            AddParametersToCommand(command, parameters);");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        using var reader = await command.ExecuteReaderAsync();");
        sb.AppendLine();
        
        GenerateDataReaderProcessing(sb, model);

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateDataReaderProcessing(StringBuilder sb, TransformationModel model)
    {
        // Determinar el tipo de clave
        var keyType = GetKeyType(model.GroupingKeys);
        
        sb.AppendLine($"        // Procesamiento con agrupamiento por {keyType}");
        sb.AppendLine($"        var groups = new Dictionary<{keyType}, List<Dictionary<string, object?>>>();");
        sb.AppendLine();
        
        sb.AppendLine("        // Leer todos los registros del DataReader");
        sb.AppendLine("        while (await reader.ReadAsync())");
        sb.AppendLine("        {");
        sb.AppendLine("            var row = new Dictionary<string, object?>();");
        sb.AppendLine("            for (int i = 0; i < reader.FieldCount; i++)");
        sb.AppendLine("            {");
        sb.AppendLine("                var fieldName = reader.GetName(i);");
        sb.AppendLine("                var value = reader.IsDBNull(i) ? null : reader.GetValue(i);");
        sb.AppendLine("                row[fieldName] = value;");
        sb.AppendLine("            }");
        sb.AppendLine();
        
        // Generar extracción de clave
        GenerateKeyExtractionFromRow(sb, model.GroupingKeys, keyType);
        
        sb.AppendLine();
        sb.AppendLine("            if (!groups.ContainsKey(key))");
        sb.AppendLine("                groups[key] = new List<Dictionary<string, object?>>();");
        sb.AppendLine();
        sb.AppendLine("            groups[key].Add(row);");
        sb.AppendLine("        }");
        sb.AppendLine();

        // Generar construcción de resultados
        GenerateResultConstructionFromRow(sb, model);
    }

    private static void GenerateKeyExtractionFromRow(StringBuilder sb, List<KeyProperty> keys, string keyType)
    {
        if (keys.Count == 1)
        {
            var key = keys.First();
            var columnName = GetColumnName(key.SourceExpression);
            sb.AppendLine($"            var key = GetTypedValue<{GetCSharpTypeForKey(key.PropertyName)}>(row, \"{columnName}\");");
        }
        else
        {
            // Clave compuesta - usar tupla
            var keyExpressions = new List<string>();
            foreach (var key in keys)
            {
                if (key.Type == KeyType.Composite)
                {
                    keyExpressions.AddRange(key.CompositeKeys.Select(expr => $"GetTypedValue<object>(row, \"{GetColumnName(expr)}\")"));
                }
                else
                {
                    keyExpressions.Add($"GetTypedValue<object>(row, \"{GetColumnName(key.SourceExpression)}\")");
                }
            }
            
            sb.AppendLine($"            var key = ({string.Join(", ", keyExpressions)});");
        }
    }

    private static void GenerateResultConstructionFromRow(StringBuilder sb, TransformationModel model)
    {
        sb.AppendLine("        // Construcción de objetos resultado");
        sb.AppendLine("        var results = new List<" + model.TargetTypeName + ">();");
        sb.AppendLine();
        sb.AppendLine("        foreach (var group in groups)");
        sb.AppendLine("        {");
        sb.AppendLine("            var groupRows = group.Value;");
        sb.AppendLine("            var firstRow = groupRows.First();");
        sb.AppendLine();

        // Generar construcción del objeto usando el modelo
        sb.AppendLine("            var result = new " + model.TargetTypeName);
        sb.AppendLine("            {");

        // Propiedades de clave
        foreach (var key in model.GroupingKeys)
        {
            var columnName = GetColumnName(key.SourceExpression);
            var csharpType = GetCSharpType(key.PropertyName);
            sb.AppendLine($"                {key.PropertyName} = GetTypedValue<{csharpType}>(firstRow, \"{columnName}\"),");
        }

        // Mapeos directos
        foreach (var mapping in model.DirectMappings)
        {
            if (mapping.SourceExpression.Contains("\"")) // Es un literal
            {
                sb.AppendLine($"                {mapping.PropertyName} = {mapping.SourceExpression},");
            }
            else
            {
                var columnName = GetColumnName(mapping.SourceExpression);
                var csharpType = GetCSharpType(mapping.PropertyName);
                sb.AppendLine($"                {mapping.PropertyName} = GetTypedValue<{csharpType}>(firstRow, \"{columnName}\"),");
            }
        }

        // Agregaciones
        foreach (var agg in model.Aggregations)
        {
            GenerateRowAggregationCode(sb, agg);
        }

        // Colecciones (básico por ahora)
        foreach (var collection in model.Collections)
        {
            sb.AppendLine($"                {collection.PropertyName} = new List<{collection.ItemTypeName}>(),");
        }

        sb.AppendLine("            };");
        sb.AppendLine();
        sb.AppendLine("            results.Add(result);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return results;");
    }

    private static void GenerateRowAggregationCode(StringBuilder sb, AggregationMapping agg)
    {
        var columnName = GetColumnName(agg.SourceExpression);
        
        switch (agg.Type)
        {
            case AggregationType.Sum:
                sb.AppendLine($"                {agg.PropertyName} = groupRows.Sum(r => GetTypedValue<decimal>(r, \"{columnName}\")),");
                break;
            case AggregationType.Count:
                sb.AppendLine($"                {agg.PropertyName} = groupRows.Count,");
                break;
            case AggregationType.Avg:
                sb.AppendLine($"                {agg.PropertyName} = groupRows.Average(r => GetTypedValue<decimal>(r, \"{columnName}\")),");
                break;
            case AggregationType.Min:
                sb.AppendLine($"                {agg.PropertyName} = groupRows.Min(r => GetTypedValue<decimal>(r, \"{columnName}\")),");
                break;
            case AggregationType.Max:
                sb.AppendLine($"                {agg.PropertyName} = groupRows.Max(r => GetTypedValue<decimal>(r, \"{columnName}\")),");
                break;
        }
    }

    private static void GenerateNpgsqlHelpers(StringBuilder sb, TransformationModel model)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Convierte un objeto anónimo a parámetros de Npgsql.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    private static void AddParametersToCommand(NpgsqlCommand command, object parameters)");
        sb.AppendLine("    {");
        sb.AppendLine("        var properties = parameters.GetType().GetProperties();");
        sb.AppendLine();
        sb.AppendLine("        foreach (var property in properties)");
        sb.AppendLine("        {");
        sb.AppendLine("            var paramName = property.Name;");
        sb.AppendLine("            var paramValue = property.GetValue(parameters) ?? DBNull.Value;");
        sb.AppendLine();
        sb.AppendLine("            command.Parameters.AddWithValue($\"@{paramName}\", paramValue);");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
        
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Obtiene un valor tipado de un dictionary row con conversión segura.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    private static T GetTypedValue<T>(Dictionary<string, object?> row, string columnName)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!row.TryGetValue(columnName, out var value) || value == null || value == DBNull.Value)");
        sb.AppendLine("        {");
        sb.AppendLine("            return default(T)!;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        if (value is T directValue)");
        sb.AppendLine("        {");
        sb.AppendLine("            return directValue;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine("            return (T)Convert.ChangeType(value, typeof(T));");
        sb.AppendLine("        }");
        sb.AppendLine("        catch");
        sb.AppendLine("        {");
        sb.AppendLine("            return default(T)!;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static string GetColumnName(string expression)
    {
        // Extraer nombre de columna de expresiones como "item.PropertyName"
        if (expression.StartsWith("item."))
        {
            return ConvertToSnakeCase(expression.Substring(5));
        }

        // Para expresiones más complejas, usar el último segmento
        var parts = expression.Split('.');
        return ConvertToSnakeCase(parts.LastOrDefault() ?? "column");
    }

    private static string ConvertToSnakeCase(string pascalCase)
    {
        if (string.IsNullOrEmpty(pascalCase))
            return pascalCase;

        var result = new StringBuilder();
        for (int i = 0; i < pascalCase.Length; i++)
        {
            if (i > 0 && char.IsUpper(pascalCase[i]))
            {
                result.Append('_');
            }
            result.Append(char.ToLower(pascalCase[i]));
        }
        return result.ToString();
    }

    private static string GetKeyType(List<KeyProperty> keys)
    {
        if (keys.Count == 0) return "object";
        if (keys.Count == 1) 
        {
            var key = keys.First();
            if (key.Type == KeyType.Composite)
            {
                // Usar tupla para claves compuestas
                var types = key.CompositeKeys.Select(_ => "object").ToList();
                return $"({string.Join(", ", types)})";
            }
            return GetCSharpTypeForKey(key.PropertyName);
        }

        // Múltiples claves - usar tupla
        var keyTypes = keys.Select(_ => "object").ToList();
        return $"({string.Join(", ", keyTypes)})";
    }

    private static string GetCSharpType(string propertyName)
    {
        var lower = propertyName.ToLower();
        
        if (lower.Contains("id")) return "int";
        if (lower.Contains("name") || lower.Contains("description")) return "string";
        if (lower.Contains("cost") || lower.Contains("price") || lower.Contains("total")) return "decimal";
        if (lower.Contains("count")) return "int";
        if (lower.Contains("date")) return "DateTime";
        if (lower.Contains("year")) return "int";
        
        return "string"; // Default to string for most cases
    }

    private static string GetCSharpTypeForKey(string propertyName)
    {
        var lower = propertyName.ToLower();
        
        if (lower.Contains("id")) return "int";
        if (lower.Contains("name")) return "string";
        if (lower.Contains("year")) return "int";
        
        return "object"; // Safe default for keys
    }
}
