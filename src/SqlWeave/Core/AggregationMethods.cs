using System.Linq.Expressions;

namespace SqlWeave.Core;

/// <summary>
/// Dummy methods that provide a compilable API before code generation.
/// These methods are replaced by interceptors at compile time.
/// </summary>
public static class AggregationMethods
{
    /// <summary>
    /// Defines a simple grouping key.
    /// </summary>
    /// <typeparam name="T">Type of the key</typeparam>
    /// <param name="value">Key value</param>
    /// <param name="skipNull">If true, skips records where the key is null</param>
    /// <returns>Dummy value (will be replaced by interceptor)</returns>
    public static T Key<T>(SqlWeaveValue value, bool skipNull = false) => default(T)!;
    
    /// <summary>
    /// Defines a simple grouping key (backward compatibility).
    /// </summary>
    /// <typeparam name="T">Type of the key</typeparam>
    /// <param name="value">Key value</param>
    /// <param name="skipNull">If true, skips records where the key is null</param>
    /// <returns>Dummy value (will be replaced by interceptor)</returns>
    public static T Key<T>(T value, bool skipNull = false) => default(T)!;

    /// <summary>
    /// Defines a composite grouping key.
    /// </summary>
    /// <typeparam name="T">Type of the resulting key</typeparam>
    /// <param name="values">Values that form the composite key</param>
    /// <returns>Dummy value (will be replaced by interceptor)</returns>
    public static T Key<T>(params object[] values) => default(T)!;

    /// <summary>
    /// Defines a grouping key generated by expression.
    /// </summary>
    /// <typeparam name="T">Type of the resulting key</typeparam>
    /// <param name="keyExpression">Expression that generates the key</param>
    /// <param name="skipNull">If true, skips records where the key is null</param>
    /// <returns>Dummy value (will be replaced by interceptor)</returns>
    public static T Key<T>(Expression<Func<SqlWeaveItem, T>> keyExpression, bool skipNull = false) => default(T)!;

    /// <summary>
    /// Defines a nested collection of grouped elements.
    /// </summary>
    /// <typeparam name="T">Type of elements in the collection</typeparam>
    /// <param name="factory">Factory function to create elements</param>
    /// <param name="skipNull">If true, skips null elements</param>
    /// <returns>Dummy list (will be replaced by interceptor)</returns>
    public static List<T> Items<T>(Func<T> factory, bool skipNull = false) => new List<T>();

    /// <summary>
    /// Calculates the sum of numeric values.
    /// </summary>
    /// <param name="value">Value to sum</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy sum (will be replaced by interceptor)</returns>
    public static decimal Sum(SqlWeaveValue value, Func<bool>? where = null) => 0m;
    
    /// <summary>
    /// Calculates the sum of numeric values (backward compatibility).
    /// </summary>
    /// <param name="value">Value to sum</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy sum (will be replaced by interceptor)</returns>
    public static decimal Sum(decimal value, Func<bool>? where = null) => 0m;

    /// <summary>
    /// Calculates the sum of numeric values.
    /// </summary>
    /// <param name="value">Value to sum</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy sum (will be replaced by interceptor)</returns>
    public static int Sum(int value, Func<bool>? where = null) => 0;

    /// <summary>
    /// Calculates the sum of numeric values.
    /// </summary>
    /// <param name="value">Value to sum</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy sum (will be replaced by interceptor)</returns>
    public static double Sum(double value, Func<bool>? where = null) => 0.0;

    /// <summary>
    /// Counts the number of elements.
    /// </summary>
    /// <param name="where">Optional condition to filter elements</param>
    /// <returns>Dummy count (will be replaced by interceptor)</returns>
    public static int Count(Func<bool>? where = null) => 0;

    /// <summary>
    /// Calculates the average of numeric values.
    /// </summary>
    /// <param name="value">Value for the average</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy average (will be replaced by interceptor)</returns>
    public static decimal Avg(SqlWeaveValue value, Func<bool>? where = null) => 0m;
    
    /// <summary>
    /// Calculates the average of numeric values (backward compatibility).
    /// </summary>
    /// <param name="value">Value for the average</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy average (will be replaced by interceptor)</returns>
    public static decimal Avg(decimal value, Func<bool>? where = null) => 0m;

    /// <summary>
    /// Calculates the average of numeric values.
    /// </summary>
    /// <param name="value">Value for the average</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy average (will be replaced by interceptor)</returns>
    public static double Avg(double value, Func<bool>? where = null) => 0.0;

    /// <summary>
    /// Finds the minimum value.
    /// </summary>
    /// <typeparam name="T">Type of the value</typeparam>
    /// <param name="value">Value to compare</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy minimum (will be replaced by interceptor)</returns>
    public static T Min<T>(T value, Func<bool>? where = null) => default(T)!;

    /// <summary>
    /// Finds the maximum value.
    /// </summary>
    /// <typeparam name="T">Type of the value</typeparam>
    /// <param name="value">Value to compare</param>
    /// <param name="where">Optional condition to filter values</param>
    /// <returns>Dummy maximum (will be replaced by interceptor)</returns>
    public static T Max<T>(T value, Func<bool>? where = null) => default(T)!;
}
