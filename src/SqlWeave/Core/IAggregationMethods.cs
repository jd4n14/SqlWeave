using System.Linq.Expressions;

namespace SqlWeave.Core;

/// <summary>
/// Interface that defines the aggregation methods available in lambda expressions.
/// This interface allows AggregationMethods to be used as a type parameter.
/// </summary>
public interface IAggregationMethods
{
    /// <summary>
    /// Defines a simple grouping key.
    /// </summary>
    T Key<T>(SqlWeaveValue value, bool skipNull = false);
    
    /// <summary>
    /// Defines a simple grouping key (backward compatibility).
    /// </summary>
    T Key<T>(T value, bool skipNull = false);

    /// <summary>
    /// Defines a composite grouping key.
    /// </summary>
    T Key<T>(params object[] values);

    /// <summary>
    /// Defines a grouping key generated by expression.
    /// </summary>
    T Key<T>(Expression<Func<SqlWeaveItem, T>> keyExpression, bool skipNull = false);

    /// <summary>
    /// Defines a nested collection of grouped elements.
    /// </summary>
    List<T> Items<T>(Func<T> factory, bool skipNull = false);

    /// <summary>
    /// Calculates the sum of numeric values.
    /// </summary>
    decimal Sum(SqlWeaveValue value, Func<bool>? where = null);
    decimal Sum(decimal value, Func<bool>? where = null);
    int Sum(int value, Func<bool>? where = null);
    double Sum(double value, Func<bool>? where = null);

    /// <summary>
    /// Counts the number of elements.
    /// </summary>
    int Count(Func<bool>? where = null);

    /// <summary>
    /// Calculates the average of numeric values.
    /// </summary>
    decimal Avg(SqlWeaveValue value, Func<bool>? where = null);
    decimal Avg(decimal value, Func<bool>? where = null);
    double Avg(double value, Func<bool>? where = null);

    /// <summary>
    /// Finds the minimum value.
    /// </summary>
    T Min<T>(T value, Func<bool>? where = null);

    /// <summary>
    /// Finds the maximum value.
    /// </summary>
    T Max<T>(T value, Func<bool>? where = null);
}

/// <summary>
/// Dummy implementation of the interface that allows compilation.
/// The real methods will be generated by interceptors.
/// </summary>
public class AggregationMethodsImpl : IAggregationMethods
{
    public T Key<T>(SqlWeaveValue value, bool skipNull = false) => AggregationMethods.Key<T>(value, skipNull);
    public T Key<T>(T value, bool skipNull = false) => AggregationMethods.Key<T>(value, skipNull);
    public T Key<T>(params object[] values) => AggregationMethods.Key<T>(values);
    public T Key<T>(Expression<Func<SqlWeaveItem, T>> keyExpression, bool skipNull = false) => AggregationMethods.Key<T>(keyExpression, skipNull);
    public List<T> Items<T>(Func<T> factory, bool skipNull = false) => AggregationMethods.Items<T>(factory, skipNull);
    public decimal Sum(SqlWeaveValue value, Func<bool>? where = null) => AggregationMethods.Sum(value, where);
    public decimal Sum(decimal value, Func<bool>? where = null) => AggregationMethods.Sum(value, where);
    public int Sum(int value, Func<bool>? where = null) => AggregationMethods.Sum(value, where);
    public double Sum(double value, Func<bool>? where = null) => AggregationMethods.Sum(value, where);
    public int Count(Func<bool>? where = null) => AggregationMethods.Count(where);
    public decimal Avg(SqlWeaveValue value, Func<bool>? where = null) => AggregationMethods.Avg(value, where);
    public decimal Avg(decimal value, Func<bool>? where = null) => AggregationMethods.Avg(value, where);
    public double Avg(double value, Func<bool>? where = null) => AggregationMethods.Avg(value, where);
    public T Min<T>(T value, Func<bool>? where = null) => AggregationMethods.Min<T>(value, where);
    public T Max<T>(T value, Func<bool>? where = null) => AggregationMethods.Max<T>(value, where);
}
